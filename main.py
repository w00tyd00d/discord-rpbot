import discord, json, os, re

from pathlib import Path
from discord.ext import tasks, commands
from random import randint

class Struct:
    def __init__(self, data):
        self.__dict__.update(data)

with open(os.path.join(os.path.dirname(__file__), "settings.json")) as f:
    settings = Struct(json.loads(f.read()))

intents = discord.Intents.all()
bot = commands.Bot(command_prefix="!", intents=intents)

guild = None # set in on_ready

adv_keys = {'adv', 'advantage', 'ad'}
dis_keys = {'dis', 'disadvantage', 'di', 'disadv'}

stat_keys = {"STR", "DEX", "CON", "WIS", "INT", "CHA"}

embed_thumbnail = "https://i.imgur.com/jrDS0br.png"

save_file = os.path.join(os.path.dirname(__file__), "data/main.json")

# Serialized data
dungeon_master_id = None


def save_data():
    with open(save_file, "w") as f:
        data = { 
            "DM": dungeon_master_id
        }

        f.write(json.dumps(data))


def load_data():
    if not Path(save_file):
        print(f"Invalid file path: {save_file}")
        return
        
    with open(save_file) as f:
        f_data = f.read()
        if f_data == "": return
        data = json.loads(f_data)

    global dungeon_master_id
    dungeon_master_id = data["DM"]


def get_member(id: int) -> discord.Member:
    """Returns a discord.Member object from the guild using a user id."""
    return guild.get_member(int(id))


def parse_dice_roll(to_roll: str) -> list[int]:
    """
    Parses the dice roll instruction and returns numeric values.

    Params:
        to_roll: The dice rolling instruction

    Returns:
        [int: Parsed dice roll instruction]
    """
    
    #parses to_roll to extract dice and dice_amount of dice
    match_res = re.match(r"(\d+)*[a-z|A-Z]+(\d+)", to_roll)
    
    if match_res is None:
       return "Error: Invalid dice roll."
    
    return [int(n) if n is not None else 1 for n in match_res.group(1, 2)]
    

def filter_dice_rolls(rolls: list[int], choice: str) -> list[int]:
    """
    Filters out a selection of dice based on the choice argument given.

    Params:
        rolls: The rolled dice list generated by rolling_time
        choice: The choice operation given

    Returns:
        [int: Filtered dice roll result(s)]
    """

    hi_lo, selection = None, 1

    if choice in adv_keys: hi_lo = 'h'
    if choice in dis_keys: hi_lo = 'l'
    
    if not hi_lo:
        res = re.match(r"([hlHL])(\d+)|(\d+)([hlHL])", choice)
        if not res:
            return "Error: Invalid choice parameter given."

        grp1, grp2 = res.group(1, 2)
        hi_lo, selection = (grp1, int(grp2)) if grp2.isdigit() else (grp2, int(grp1))
        
        hi_lo = res.group(1) if not res.group(1).isdigit() else res.group(2)
        selection = int(res.group(1)) if res.group(1).isdigit() else int(res.group(2))
        
    # Reduce the selection of rolled dice based on parameters
    return sorted(rolls, reverse = True if hi_lo == 'h' else False)[:selection]


def rolling_time(dice_amount: int, dice_type: int) -> list[int]:
    """
    Returns a randomized list of integers based on the rolling parameters.

    Params:
        dice_amount: The amount of total dice to be rolled
        dice_type: int the type of dice to be rolled as an integer signifying number of faces of dice
    
    Returns:
        [int: Resulting dice roll(s)]
    """
    return [randint(1, dice_type) for _ in range(dice_amount)]    


def parse_extra_ops(op1: str, op2: str) -> tuple:
    """
    Parses any additional operation given by a roll command and returns
    them in a deterministic order.

    Params:
        op1: The first operation given
        op2: The second operation given

    Returns:
        (bool, choice | None, modifier | None)
        
        bool:     Whether or not the operations given were valid
        choice:   The dice filtering option (if one is provided)
        modifier: The stat modifier (if one is provided)
    """
    choice, modifier = None, None
    
    def is_choice(op: str) -> bool:
        if  (op in adv_keys or op in dis_keys
            (op[0].isdigit() and op[-1] in ("h", "l")) or
            (op[-1].isdigit() and op[0] in ("h", "l"))):
                return True
        return False

    def is_modifier(op: str) -> bool:
        if (op in stat_keys or
            op.isdigit() or
            op[0] in {"+", "-"} and op[1:].isdigit()):
                return True
        return False

    for op in [op1, op2]:
        if op is None: continue

        if is_choice(op):
            if choice is not None:
                return False, choice, modifier
            choice = op
        elif is_modifier(op):
            if modifier is not None:
                return False, choice, modifier
            if op in stat_keys:
                # ADD PROFILE SUPPORT HERE
                modifier = 0
            else:
                modifier = int(op)
        else:
            return False, choice, modifier

    return True, choice, modifier


def create_roll_embed(rolls: list[int], selection: list[int] = None, modifier: int|str = None) -> discord.Embed:
    embed = discord.Embed(
        title="Roll Results",
        description=", ".join([str(n) for n in rolls]),
        color=discord.Color.blue()
    )
    
    embed.set_thumbnail(url=embed_thumbnail)

    if selection:
        embed.add_field(name="Selection", value=", ".join([str(n) for n in selection]))
    
    if modifier is not None:
        embed.add_field(name="Modifier", value="{0:+}".format(modifier))
    else:
        # Hard set modifier to 0 for sum calculation
        modifier = 0
    
    result = sum(selection) if selection else sum(rolls)
    embed.add_field(name="Result", value=f'{result + modifier}', inline=False)
    
    return embed


def create_stat_roll_embed(rolls: list[list], selections: list[list]) -> discord.Embed:
    desc_string = "\n".join([", ".join([str(n) for n in roll]) for roll in rolls])
    
    embed = discord.Embed(
        title="Stat Roll Results",
        description=desc_string,
        color=discord.Color.blue()
    )
    
    embed.set_thumbnail(url=embed_thumbnail)

    selstr = "\n".join([", ".join([str(n) for n in roll]) for roll in selections])
    result = ", ".join([sum(r) for r in selections])
    
    embed.add_field(name="Selection", value=selstr)
    embed.add_field(name="Result", value=result, inline=False)
    
    return embed


def get_roll_results(to_roll: str, op1: str, op2: str) -> tuple:
    """
    Returns the results of a roll command.

    Params:
        to_roll: The dice rolling instruction
        op1: The first extra operation
        op2: The second extra operation
    
    Returns:
        (str | None, discord.Embed | None)

        str: The string that will be printed directly within the replying msg
        discord.Embed: The rich embed object displaying the results
    """
    
    res, choice, modifier = parse_extra_ops(op1, op2)

    if not res:
        return "Invalid extra operations.", None

    modifier = 0 if modifier is None else int(modifier)
    parsed = parse_dice_roll(to_roll)
    
    if parsed[0:5] == 'Error':
        return parsed, None

    rolls = rolling_time(*parsed)
    
    if choice is None:
        return f'Rolled dice output: {rolls}, Modifier is {modifier}, Sum of rolls: {sum(rolls) + modifier}', None

    selected = filter_dice_rolls(rolls, choice)

    if type(selected) == str:
        return selected, None
    
    return f'Selected dice: {selected}, Modifier is {modifier}, Sum of selected dice: {sum(selected) + modifier}, every dice outcome:{rolls}', None
    

async def send_message(channel: discord.GroupChannel, msg: str, embed: discord.Embed = None):
    if channel is None:
        print("Error: Channel does not exist.")
        return
    await channel.send(msg, embed=embed)


async def send_direct_message(user: discord.Member, msg: str, embed: discord.Embed = None):
    await user.create_dm()
    await send_message(user.dm_channel, msg, embed=embed)


@bot.event
async def on_ready():
    print(f'{bot.user} has connected to Discord!')
    
    global guild
    guild = bot.get_guild(settings.guild_id)    
    
    if settings.debug_mode:
        user = get_member(settings.debug_user_id)
        await send_direct_message(user, "Logged in!")
    
    load_data()
    

@bot.command()
async def test(ctx):
    await send_message(ctx.channel, "Test successful!")
    await send_message(ctx.channel, f"The current DM is : {get_member(dungeon_master_id).display_name}")


@bot.command(name="dm")
async def register_dm(ctx, user : discord.Member = None):
    user = user if user is not None else ctx.author

    global dungeon_master_id
    dungeon_master_id = user.id

    await send_message(ctx.channel, f"{user.display_name} is now the DM!")

    save_data()


@bot.command(name="roll")
async def roll_dice(ctx, to_roll, op1 = None, op2 = None):
    string, embed = get_roll_results(to_roll, op1, op2)
    await send_message(ctx.channel, string, embed)
    

@bot.command(name="rollstats")
async def roll_stats(ctx):
    res = "Stat rolls results:\n"
    
    for i in range(6):
        rolls = rolling_time(4, 6)
        selected = filter_dice_rolls(rolls, 'h3')
        res += f'Stats total: {sum(selected)}, rolled dice: {rolls}, dice selected (highest 3): {selected}'
        if i < 5: res += "\n"
    
    await send_message(ctx.channel, res)
        

@bot.command(name="rolldm")
async def roll_dice_dm(ctx, to_roll, op1 = None, op2 = None):
    string, embed = get_roll_results(to_roll, op1, op2)
    dm = get_member(dungeon_master_id)

    if ctx.author != dm:
        await send_direct_message(ctx.author, string, embed)

    await send_direct_message(dm, string, embed)


if __name__ == "__main__":
    bot.run(settings.discord_token)
