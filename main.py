import discord, json, os, re

from pathlib import Path
from discord.ext import commands
from random import randint

class Struct:
    def __init__(self, data):
        self.__dict__.update(data)

with open(os.path.join(os.path.dirname(__file__), "settings.json")) as f:
    settings = Struct(json.loads(f.read()))

intents = discord.Intents.all()
bot = commands.Bot(command_prefix="!", intents=intents)

guild = None # set in on_ready

adv_keys = ("advantage",)
dis_keys = ("disadvantage",)
stat_keys = ("strength", "dexterity", "constitution", "wisdom", "intelligence", "charisma")

embed_thumbnail = "https://i.imgur.com/jrDS0br.png"

save_file = os.path.join(os.path.dirname(__file__), "data/main.json")

# Serialized data
dungeon_master_id = None


def save_data():
    with open(save_file, "w") as f:
        data = { 
            "DM": dungeon_master_id
        }

        f.write(json.dumps(data))


def load_data():
    if not Path(save_file):
        print(f"Invalid file path: {save_file}")
        return
        
    with open(save_file) as f:
        f_data = f.read()
        if f_data == "": return
        data = json.loads(f_data)

    global dungeon_master_id
    dungeon_master_id = data["DM"]


def is_lazy_key(tup: tuple, key: str) -> bool:
    """Checks if lazy key belongs to corresponding key set."""
    if not key or len(key) < 3:
        return False

    for k in tup:
        if k.startswith(key.lower()):
            return True
    return False


def get_member(id: int) -> discord.Member:
    """Returns a discord.Member object from the guild using a user id."""
    return guild.get_member(int(id))


def parse_dice_roll(to_roll: str) -> list[int]:
    """
    Parses the dice roll instruction and returns numeric values.

    Params:
        to_roll: The dice rolling instruction

    Returns:
        [int: Parsed dice roll instruction]
    """
    
    # Stistows: parses to_roll to extract dice and dice_amount of dice
    match_res = re.match(r"(\d+)*[dD]+(\d+)", to_roll)
    
    if match_res is None:
       return "Error: Invalid dice roll."
    
    return [int(n) if n is not None else 1 for n in match_res.group(1, 2)]
    

def filter_dice_rolls(rolls: list[int], choice: str) -> list[int]:
    """
    Filters out a selection of dice based on the choice argument given.

    Params:
        rolls: The rolled dice list generated by rolling_time
        choice: The choice operation given

    Returns:
        [int: Filtered dice roll result(s)]
    """

    # hi_lo, selection = None, 1

    res = re.match(r"([hlHL])(\d+)|(\d+)([hlHL])", choice)
    if not res:
        return "Error: Invalid choice parameter given."

    grp1, grp2 = res.group(1, 2)
    hi_lo, selection = (grp1, int(grp2)) if grp2.isdigit() else (grp2, int(grp1))
    
    hi_lo = res.group(1) if not res.group(1).isdigit() else res.group(2)
    selection = int(res.group(1)) if res.group(1).isdigit() else int(res.group(2))
        
    # Stistows: Reduce the selection of rolled dice based on parameters
    return sorted(rolls, reverse = True if hi_lo == 'h' else False)[:selection]


def rolling_time(dice_amount: int, dice_type: int) -> list[int]:
    """
    Returns a randomized list of integers based on the rolling parameters.

    Params:
        dice_amount: The amount of total dice to be rolled
        dice_type: int the type of dice to be rolled as an integer signifying number of faces of dice
    
    Returns:
        [int: Resulting dice roll(s)]
    """
    return [randint(1, dice_type) for _ in range(dice_amount)]    


def parse_extra_ops(op1: str, op2: str) -> tuple:
    """
    Parses any additional operation given by a roll command and returns
    them in a deterministic order.

    Params:
        op1: The first operation given
        op2: The second operation given

    Returns:
        (bool, choice | None, modifier | None)
        
        bool:     Whether or not the operations given were valid
        choice:   The dice filtering option (if one is provided)
        modifier: The stat modifier (if one is provided)
    """
    choice, modifier = None, None
    
    def is_choice(op: str) -> bool:
        if ((op[0].isdigit() and op[-1] in {"h", "l"}) or
            (op[-1].isdigit() and op[0] in {"h", "l"})):
                return True
        return False

    def is_modifier(op: str) -> bool:
        if (is_lazy_key(stat_keys, op) or
            op.isdigit() or
            op[0] in {"+", "-"} and op[1:].isdigit()):
                return True
        return False

    for op in [op1, op2]:
        if op is None: continue

        if is_choice(op):
            if choice is not None:
                return False, choice, modifier
            choice = op
        elif is_modifier(op):
            if modifier is not None:
                return False, choice, modifier
            modifier = op if is_lazy_key(stat_keys, op) else int(op)
        else:
            return False, choice, modifier

    return True, choice, modifier


def create_roll_embed(dice_type: str, rolls: list[int], selection: list[int] = None, modifier: int|str = None) -> discord.Embed:
    """
    Creates and returns an embed to display the results of a roll command.

    Params:
        rolls: This list of resulting rolls made
        selection: The filtered selection, if one exists
        modifier: The additional modifier, if one exists

    Returns:
        discord.Embed: A rich discord embed object containing the results of the
            roll command
    """
    
    embed = discord.Embed(
        title=f"D{dice_type} Roll Results",
        description=", ".join([str(n) for n in rolls]),
        color=discord.Color.blue()
    )
    
    embed.set_thumbnail(url=embed_thumbnail)

    if selection:
        embed.add_field(name="Selection", value=", ".join([str(n) for n in selection]))
    
    if modifier is not None:
        if is_lazy_key(stat_keys, modifier):
            # w00t: ADD PROFILE SUPPORT HERE
            modstr = f"{0:+} ({modifier.upper()[:3]})"
            modifier = 0
        else:
            modstr = f"{modifier:+}"

        embed.add_field(name="Modifier", value=modstr)
    else:
        # w00t: Hard set modifier to 0 for sum calculation
        modifier = 0
    
    result = sum(selection) if selection else sum(rolls)
    embed.add_field(name="Result", value=f'{result + modifier}', inline=False)
    
    return embed


def create_stat_roll_embed(rolls: list[list], selections: list[list]) -> discord.Embed:
    """
    Creates and returns an embed to display the results of a roll stats command.

    Params:
        rolls: This list of each resulting roll made for each stat
        selections: The filtered selection of each stat roll

    Returns:
        discord.Embed: A rich discord embed object containing the results of the
            roll stats command
    """
    
    desc_string = "\n".join([", ".join([str(n) for n in roll]) for roll in rolls])
    
    embed = discord.Embed(
        title="Stat Roll Results",
        description=desc_string,
        color=discord.Color.blue()
    )
    
    embed.set_thumbnail(url=embed_thumbnail)

    selstr = "\n".join([", ".join([str(n) for n in roll]) for roll in selections])
    result = ", ".join([str(sum(r)) for r in selections])
    
    embed.add_field(name="Selection", value=selstr)
    embed.add_field(name="Result", value=result, inline=False)
    
    return embed


def get_roll_results(to_roll: str, op1: str, op2: str) -> tuple:
    """
    Returns the results of a roll command.

    Params:
        to_roll: The dice rolling instruction
        op1: The first extra operation
        op2: The second extra operation
    
    Returns:
        (str | None, discord.Embed | None)

        str: The string that will be printed directly within the replying msg
        discord.Embed: The rich embed object displaying the results
    """
    
    if is_lazy_key(adv_keys, to_roll) or is_lazy_key(dis_keys, to_roll):
        if op1 is not None and op2 is not None:
            return "Invalid extra operations.", None

        op2 = "h1" if is_lazy_key(adv_keys, to_roll) else "l1"
        to_roll = "2d20"

    elif is_lazy_key(stat_keys, to_roll):
        if op1 is not None and op2 is not None:
            return "Invalid extra operations.", None

        is_adv_key = is_lazy_key(adv_keys, op1)
        is_dis_key = is_lazy_key(dis_keys, op1)

        op2 = to_roll
        to_roll = "2d20" if is_adv_key or is_dis_key else "d20"
        op1 = "h1" if is_adv_key else "l1"
    
    res, choice, modifier = parse_extra_ops(op1, op2)

    if not res:
        return "Invalid extra operations.", None

    parsed = parse_dice_roll(to_roll)
    
    if parsed[0:5] == 'Error':
        return parsed, None

    rolls = rolling_time(*parsed)
    selected = filter_dice_rolls(rolls, choice) if choice else None
    embed = create_roll_embed(parsed[1], rolls, selected, modifier)
    
    return "", embed
    

async def send_message(channel: discord.GroupChannel, msg: str, embed: discord.Embed = None):
    if channel is None:
        print("Error: Channel does not exist.")
        return
    await channel.send(msg, embed=embed)


async def send_direct_message(user: discord.Member, msg: str, embed: discord.Embed = None):
    await user.create_dm()
    await send_message(user.dm_channel, msg, embed=embed)


@bot.event
async def on_ready():
    print(f'{bot.user} has connected to Discord!')
    
    global guild
    guild = bot.get_guild(settings.guild_id)    
    
    if settings.debug_mode:
        user = get_member(settings.debug_user_id)
        await send_direct_message(user, "Logged in!")
    
    load_data()
    

@bot.command()
async def test(ctx):
    await send_message(ctx.channel, "Test successful!")
    await send_message(ctx.channel, f"The current DM is : {get_member(dungeon_master_id).display_name}")


@bot.command(name="dm")
async def register_dm(ctx, user : discord.Member = None):
    user = user if user is not None else ctx.author

    global dungeon_master_id
    dungeon_master_id = user.id

    await send_message(ctx.channel, f"{user.display_name} is now the DM!")

    save_data()


@bot.command(name="roll")
async def roll_dice(ctx, to_roll = "d20", op1 = None, op2 = None):
    string, embed = get_roll_results(to_roll, op1, op2)
    await send_message(ctx.channel, string, embed)


@bot.command(name="rolldm")
async def roll_dice_dm(ctx, to_roll = "d20", op1 = None, op2 = None):
    string, embed = get_roll_results(to_roll, op1, op2)
    dm = get_member(dungeon_master_id)

    if ctx.author != dm or not embed:
        await send_direct_message(ctx.author, string, embed)

    if embed:
        string = f"{ctx.author.display_name} rolled the dice!\n" # ADD QUIP FUNCTION HERE
        await send_direct_message(dm, string, embed)
    

@bot.command(name="rollstats")
async def roll_stats(ctx):
    all_rolls = []
    all_selected = []
    
    for i in range(6):
        rolls = rolling_time(4, 6)
        selected = filter_dice_rolls(rolls, 'h3')

        all_rolls.append(rolls)
        all_selected.append(selected)
    
    embed = create_stat_roll_embed(all_rolls, all_selected)
    await send_message(ctx.channel, "", embed)


if __name__ == "__main__":
    bot.run(settings.discord_token)
